J = c(4, 4, 4, 9, 10, 11, 12)
p = 3
seq_along(J)
seq_along(J)-3
seq_along(J-3)
seq(length(7))
seq(length(J))
seq(length(J)-p)
J = c(4, 4, 4, 9, 10, 11, 12)
p = 3
for (i in seq(length(J)-p)) {
K <- J[i:i+p]
print(K)
}
J[1]
J[1:2]
seq(length(J)-p)
J[1:4]
for (i in seq(length(J)-p)) {
K <- J[i:(i+p)]
print(K)
}
for (i in seq(length(J)-p-1)) {
K <- J[i:(i+p-1)]
print(K)
}
for (i in seq(length(J)-p)) {
K <- J[i:(i+p-1)]
print(K)
}
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
print(K)
}
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
mean(K)
}
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
print(mean(K))
}
J <- c(4, 4, 4, 9, 10, 11, 12)
p <- 3
M <- c()
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
M <- c(M, mean(K))
}
print(min(M))
print(max(M))
# (4,9,10)
#
# (9,10,11)
#
# (10,11,12)
#
#
# Here the minimum average will be 4 and the maximum average will be 11, which corresponds
# to the first and last sequences. Solution will be provided in Python for premium users.
#
minmaxaverages <- function(J=c(4, 4, 4, 9, 10, 11, 12), p=3){
M <- c()
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
M <- c(M, mean(K))
}
print(min(M))
print(max(M))
return(list(mn=min(M), mx=max(M)))
}
mma <- mminmaxaverages()
mma <- minmaxaverages()
mma
minmaxaverages <- function(J=c(4, 4, 4, 9, 10, 11, 12), p=3){
M <- c()
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
M <- c(M, mean(K))
}
return(list(mn=min(M), mx=max(M)))
}
J <- c(4, 4, 4, 9, 10, 11, 12)
p <- 3
mma <- minmaxaverages(J, p)
print(mma)
minmaxaverages <- function(J=c(4, 4, 4, 9, 10, 11, 12), p=3){
M <- c()
for (i in seq(length(J)-p+1)) {
K <- J[i:(i+p-1)]
M <- c(M, mean(K))
}
return(list(min=min(M), max=max(M)))
}
J <- c(4, 4, 4, 9, 10, 11, 12)
p <- 3
mma <- minmaxaverages(J, p)
print(mma)
# This problem was asked by Stripe.
#
# Given an array of integers, find the first missing positive integer in linear time
# and constant space. In other words, find the lowest positive integer that does not
# exist in the array. The array can contain duplicates and negative numbers as well.
#
# For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
#
# You can modify the input array in-place.
#
input <- c(3, 4, -1, 1)
# This problem was asked by Stripe.
#
# Given an array of integers, find the first missing positive integer in linear time
# and constant space. In other words, find the lowest positive integer that does not
# exist in the array. The array can contain duplicates and negative numbers as well.
#
# For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
#
# You can modify the input array in-place.
#
input <- c(3, 4, -1, 1)
input[input>0]
sort(input)
# This problem was asked by Stripe.
#
# Given an array of integers, find the first missing positive integer in linear time
# and constant space. In other words, find the lowest positive integer that does not
# exist in the array. The array can contain duplicates and negative numbers as well.
#
# For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
#
# You can modify the input array in-place.
#
input <- c(3, 4, -1, 1)
input <- input[input>0]
input <- sort(input)
# This problem was asked by Stripe.
#
# Given an array of integers, find the first missing positive integer in linear time
# and constant space. In other words, find the lowest positive integer that does not
# exist in the array. The array can contain duplicates and negative numbers as well.
#
# For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
#
# You can modify the input array in-place.
#
input <- c(3, 4, -1, 1)
input <- input[input>0]
input <- c(0, sort(input))
diff(input)
diff(input) > 1
input[diff(input) > 1]
input[2:length(input)][diff(input) > 1]
input[length(input)][diff(input) > 1][1]
input[length(input)][diff(input) > 1]
input[diff(input) > 1][1]
input[diff(input) > 1][1] + 1
print(input[diff(input) > 1][1] + 1)
input <- c(3, 4, -1, 1)
# input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input))
print(input[diff(input) > 1][1] + 1)
input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input))
print(input[diff(input) > 1][1] + 1)
input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
print(input[diff(input) > 1][1] + 1)
input <- c(3, 4, -1, 1)
# input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
print(input[diff(input) > 1][1] + 1)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
# This problem was asked by Stripe.
#
# Given an array of integers, find the first missing positive integer in linear time
# and constant space. In other words, find the lowest positive integer that does not
# exist in the array. The array can contain duplicates and negative numbers as well.
#
# For example, the input [3, 4, -1, 1] should give 2. The input [1, 2, 0] should give 3.
#
# You can modify the input array in-place.
#
input <- c(3, 4, -1, 1)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
input[diff(input) > 1][1] + 1
input[diff(input) > 1]
input <- c(1,1,1,1,1)
# input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
input <- c(-1,-1,-1)
# input <- c(1, 2, 0)
input <- input[input>0]
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
input <- c(-1,-1,-1)
input <- c(-1,-1,-1)
input[input>0]
length(input[input>0])
input <- c(-1,-1,-1)
# input <- c(1, 2, 0)
input <- input[input>0]
if(length(input) == 0) {input <- 0}
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
input <- c(0)
# input <- c(1, 2, 0)
input <- input[input>0]
if(length(input) == 0) {input <- 0}
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
input <- c(100)
# input <- c(1, 2, 0)
input <- input[input>0]
if(length(input) == 0) {input <- 0}
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
input <- c(1,2,3,4,5,6,7,10)
# input <- c(1, 2, 0)
input <- input[input>0]
if(length(input) == 0) {input <- 0}
input <- c(0, sort(input), max(input)+2)
answer <- input[diff(input) > 1][1] + 1
print(answer)
cons <- function(a, b) {
pair <- function(f) {
return(f(a, b))
}
}
cons(1,2)
cons
print(cons(1,2))
p <- cons(1, 2)
p
p[1]
p()
u <- 0.35
lu <- 0.2
n <- 0.25
u + lu + n
l <- 1 - (u + lu + n)
l
ans <- l + lu
ans
print(paste(ans*100, "%"))
# Data Interview Questions: Problem #3
#
# Question 3 - The carshare dilemma
# Suppose we have selected a group of people to take a survey. 35% of the group like Uber,
# 20% like both Lyft and Uber, and 25% like neither Lyft nor Uber. Given this information,
# what percentage of the sample likes Lyft?
#
# Hint: You can use basic probability theory to solve this problem.
u <- 0.35
lu <- 0.2
n <- 0.25
l <- 1 - (u + lu + n)
ans <- l + lu
print(paste0(ans*100, "%"))
# Data Interview Questions: Problem #3
#
# Question 3 - The carshare dilemma
# Suppose we have selected a group of people to take a survey. 35% of the group like Uber,
# 20% like both Lyft and Uber, and 25% like neither Lyft nor Uber. Given this information,
# what percentage of the sample likes Lyft?
#
# Hint: You can use basic probability theory to solve this problem.
u <- 0.35
lu <- 0.2
n <- 0.25
l <- 1 - (u + lu + n)
ans <- l + lu
print(paste0(ans*100, "% like Lyft"))
